use crate::reprs::ast::*;
use crate::{common::WithInfo, reprs::common::Span};

grammar();

extern {
    type Error = crate::parsing::UserParserError;
}

CommaSep<T>: Vec<T> = {
    <mut start:(<T> ",")*> <last:T?> => {
        if let Some(last) = last {
            start.push(last);
        }
        start
    },
}

Box<T>: Box<T> = <T> => Box::new(<>);

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
} else {
    _
}

Ident: Ident<'input> = <r"[a-zA-Z]+"> => Ident { name: <> };

WithInfo<T>: WithInfo<Span<'input>, T> = {
    <start:@L> <inner:T> <end:@R> => WithInfo(Span {
        text: &input[start..end],
        start,
    }, inner),
}

pub Term: Term<'input> = WithInfo<RawTerm>;

RawTerm: RawTerm<'input> = {
    Abs,
    App<Abs>,
    Dot<Abs>,
    SimpleTerm,
}

Abs: RawTerm<'input> = {
    "\\" <arg:Assignee> <arg_type:(":" <Type>)?> <body:Box<Term>> => RawTerm::Abs { arg, arg_type, body },
    "?" <arg:Ident> <bounds:TyBounds> <body:Box<Term>> => RawTerm::TyAbs { arg, bounds, body },
}

App<Abs>: RawTerm<'input> = {
    <func:Box<WithInfo<AppLeft>>> <arg:Box<WithInfo<AppRight<Abs>>>> => RawTerm::App { func, arg },
    <func:Box<WithInfo<AppLeft>>> "[" <arg:Box<Type>> "]" => RawTerm::TyApp { func, arg },
}

Dot<Abs>: RawTerm<'input> = {
    <arg:Box<WithInfo<DotLeft>>> "." <func:Box<WithInfo<DotRight<Abs>>>> => RawTerm::App { func, arg },
}

NoAbs: RawTerm<'input> = {}
AppLeft       = {      App<NoAbs>, Dot<NoAbs>, SimpleTerm }
AppRight<Abs> = { Abs,             Dot<Abs>,   SimpleTerm }
DotLeft       = {                  Dot<NoAbs>, SimpleTerm }
DotRight<Abs> = { Abs,                         SimpleTerm }

SimpleTerm: RawTerm<'input> = {
    // TODO: capture the inner info instead
    "(" <RawTerm> ")",

    Ident => RawTerm::Var(<>),

    "enum" <(":" <Type>)?> <Ident> => RawTerm::Enum(<>),
    "match" <ty:(":" <Type>)?> "{" <arms:CommaSep<(Ident Term)>> "}" => RawTerm::Match(ty, arms.into_boxed_slice()),

    "{" <CommaSep<(<Ident> ":" <Term>)>> "}" => RawTerm::Record(<>.into_boxed_slice()),

    Tuple<Term> => RawTerm::Tuple(<>),

    "true" => RawTerm::Bool(true),
    "false" => RawTerm::Bool(false),
}

Assignee: Assignee<'input> = {
    "{" <CommaSep<(Ident (":" <Assignee>)?)>> "}" => Assignee::Record(<>.into_boxed_slice()),
    Tuple<Assignee> => Assignee::Tuple(<>),
    Ident => Assignee::Ident(<>),
}

TyBounds: TyBounds<'input> = {
    <upper:("<" <Type>)?> <lower:(">" <Type>)?> => TyBounds { upper, lower },
}

Tuple<T>: Box<[T]> = {
    "(" ")" => Box::new([]),
    // require trailing comma on 1-tuple
    "(" <T> "," ")" => Box::new([<>]),
    "(" <first:T> <rest:("," <T>)+> ","? ")" => std::iter::once(first).chain(rest).collect(),
}

Type: Type<'input> = WithInfo<RawType>;

RawType: RawType<'input> = {
    <arg:Box<WithInfo<SimpleType>>> "->" <result:Box<Type>> => RawType::Arr { arg, result },

    "[" <arg:Ident> <bounds:Box<TyBounds>> "]" <result:Box<Type>> => RawType::TyAbs { arg, bounds, result },

    SimpleType,
}
SimpleType: RawType<'input> = {
    // TODO: capture the inner info instead
    "(" <RawType> ")",

    Ident => RawType::TyVar(<>),

    "enum" "{" <variants:CommaSep<(<Ident> ":" <Type>)>> "}" =>
        RawType::Enum(variants.into_boxed_slice()),
    "{" <CommaSep<(<Ident> ":" <Type>)>> "}" =>
        RawType::Record(<>.into_boxed_slice()),
    Tuple<Type> => RawType::Tuple(<>),

    "bool" => RawType::Bool,
    "_" => RawType::Any,
    "!" => RawType::Never,
}
