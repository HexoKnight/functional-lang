use crate::reprs::ast::*;
use crate::{common::WithInfo, reprs::common::{FileInfo, Span}};

grammar(file_info: &'input FileInfo<'input>);

extern {
    type Error = crate::parsing::UserParserError;
}

CommaSep<T>: Vec<T> = {
    <mut start:(<T> ",")*> <last:T?> => {
        if let Some(last) = last {
            start.push(last);
        }
        start
    },
}

Box<T>: Box<T> = <T> => Box::new(<>);

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},

    _,

    r"[a-zA-Z]+" => IDENT,
    r"\./[^\s]+" => RELATIVE_PATH,
    r"@[a-zA-Z]+/[^\s]+" => PACKAGE_PATH,
}

Spanned<T>: (Span<'input>, T) = <start:@L> <inner:T> <end:@R> => (Span::new(file_info, start..end), inner);

WithInfo<T>: WithInfo<Span<'input>, T> = <s:Spanned<T>> => WithInfo(s.0, s.1);

Ident: Ident<'input> = Spanned<IDENT> => Ident(<>.0);
ImportPath: ImportPath<'input> = {
    Spanned<RELATIVE_PATH> => ImportPath::Relative { span: <>.0 },
    Spanned<PACKAGE_PATH> => {
        let [package, path] = <>.0.map_text_array(|s| s[1..].split_once('/').map(|(a, b)| [a, b]).unwrap());
        ImportPath::Package { span: <>.0, package, path }
    },
}

pub Term: Term<'input> = WithInfo<RawTerm>;

RawTerm: RawTerm<'input> = {
    Abs,
    App<Abs>,
    Dot<Abs>,
    SimpleTerm,
}

Abs: RawTerm<'input> = {
    "\\" <arg:Assignee> <arg_type:(":" <Type>)?> <body:Box<Term>> => RawTerm::Abs { arg, arg_type, body },
    "?" <arg:Ident> <bounds:TyBounds> <body:Box<Term>> => RawTerm::TyAbs { arg, bounds, body },
}

App<Abs>: RawTerm<'input> = {
    <func:Box<WithInfo<AppLeft>>> <arg:Box<WithInfo<AppRight<Abs>>>> => RawTerm::App { func, arg },
    <func:Box<WithInfo<AppLeft>>> "[" <arg:Box<Type>> "]" => RawTerm::TyApp { func, arg },
}

Dot<Abs>: RawTerm<'input> = {
    <arg:Box<WithInfo<DotLeft>>> "." <func:Box<WithInfo<DotRight<Abs>>>> => RawTerm::App { func, arg },
}

NoAbs: RawTerm<'input> = {}
AppLeft       = {      App<NoAbs>, Dot<NoAbs>, SimpleTerm }
AppRight<Abs> = { Abs,             Dot<Abs>,   SimpleTerm }
DotLeft       = {                  Dot<NoAbs>, SimpleTerm }
DotRight<Abs> = { Abs,                         SimpleTerm }

SimpleTerm: RawTerm<'input> = {
    // TODO: capture the inner info instead
    "(" <RawTerm> ")",

    Ident => RawTerm::Var(<>),

    "import" <ImportPath> => RawTerm::Import(<>),

    "enum" <(":" <Type>)?> <Ident> => RawTerm::Enum(<>),
    "match" <ty:(":" <Type>)?> "{" <arms:CommaSep<(Ident Term)>> "}" => RawTerm::Match(ty, arms.into_boxed_slice()),

    "{" <CommaSep<(<Ident> ":" <Term>)>> "}" => RawTerm::Record(<>.into_boxed_slice()),

    Tuple<Term> => RawTerm::Tuple(<>),

    "true" => RawTerm::Bool(true),
    "false" => RawTerm::Bool(false),
}

Assignee: Assignee<'input> = WithInfo<RawAssignee>;

RawAssignee: RawAssignee<'input> = {
    "{" <CommaSep<(Ident (":" <Assignee>)?)>> "}" => RawAssignee::Record(<>.into_boxed_slice()),
    Tuple<Assignee> => RawAssignee::Tuple(<>),
    Ident => RawAssignee::Ident(<>),
}

TyBounds: TyBounds<'input> = {
    <upper:("<" <Type>)?> <lower:(">" <Type>)?> => TyBounds { upper, lower },
}

Tuple<T>: Box<[T]> = {
    "(" ")" => Box::new([]),
    // require trailing comma on 1-tuple
    "(" <T> "," ")" => Box::new([<>]),
    "(" <first:T> <rest:("," <T>)+> ","? ")" => std::iter::once(first).chain(rest).collect(),
}

Type: Type<'input> = WithInfo<RawType>;

RawType: RawType<'input> = {
    <arg:Box<WithInfo<SimpleType>>> "->" <result:Box<Type>> => RawType::Arr { arg, result },

    "[" <arg:Ident> <bounds:Box<TyBounds>> "]" <result:Box<Type>> => RawType::TyAbs { arg, bounds, result },

    SimpleType,
}
SimpleType: RawType<'input> = {
    // TODO: capture the inner info instead
    "(" <RawType> ")",

    Ident => RawType::TyVar(<>),

    "enum" "{" <variants:CommaSep<(<Ident> ":" <Type>)>> "}" =>
        RawType::Enum(variants.into_boxed_slice()),
    "{" <CommaSep<(<Ident> ":" <Type>)>> "}" =>
        RawType::Record(<>.into_boxed_slice()),
    Tuple<Type> => RawType::Tuple(<>),

    "bool" => RawType::Bool,
    "_" => RawType::Any,
    "!" => RawType::Never,
}
