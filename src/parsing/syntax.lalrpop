use crate::reprs::ast::*;
use crate::{common::WithInfo, reprs::common::Span};

grammar();

extern {
    type Error = crate::parsing::UserParserError;
}

CommaSep<T>: Vec<T> = {
    <mut start:(<T> ",")*> <last:T?> => {
        if let Some(last) = last {
            start.push(last);
        }
        start
    },
}

Box<T>: Box<T> = <T> => Box::new(<>);

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
} else {
    _
}

Ident: Ident<'input> = <r"[a-zA-Z]+"> => Ident { name: <> };

WithInfo<T>: WithInfo<Span<'input>, T> = {
    <start:@L> <inner:T> <end:@R> => WithInfo(Span {
        text: &input[start..end],
        start,
    }, inner),
}

pub Term: Term<'input> = WithInfo<RawTerm>;

RawTerm: RawTerm<'input> = {
    #[precedence(level="2")]
    "\\" <arg:Assignee> ":" <arg_type:Type> <body:Box<WithInfo<RawTerm>>> => RawTerm::Abs { arg, arg_type, body },

    #[precedence(level="1")]
    #[assoc(side="left")]
    <func:Box<WithInfo<RawTerm>>> <arg:Box<WithInfo<RawTerm>>> => RawTerm::App { func, arg },

    #[precedence(level="0")]
    SimpleTerm,
}

SimpleTerm: RawTerm<'input> = {
    // TODO: capture the inner info instead
    "(" <RawTerm> ")",

    <ident:Ident> =>? {
        Ok(RawTerm::Var { ident })
    },

    "enum" <Type> <Ident> => RawTerm::Enum(<>),

    Tuple<Term> => RawTerm::Tuple(<>),

    "true" => RawTerm::Bool(true),
    "false" => RawTerm::Bool(false),
}

Assignee: Assignee<'input> = {
    Tuple<Assignee> => Assignee::Tuple(<>),
    Ident => Assignee::Ident(<>),
}

Tuple<T>: Box<[T]> = {
    "(" ")" => Box::new([]),
    // require trailing comma on 1-tuple
    "(" <T> "," ")" => Box::new([<>]),
    "(" <first:T> <rest:("," <T>)+> ","? ")" => std::iter::once(first).chain(rest).collect(),
}

Type: Type<'input> = WithInfo<RawType>;

RawType: RawType<'input> = {
    #[precedence(level="1")]
    #[assoc(side="right")]
    <arg:Box<WithInfo<RawType>>> "->" <result:Box<WithInfo<RawType>>> => RawType::Arr { arg, result },

    #[precedence(level="0")]
    SimpleType,
}
SimpleType: RawType<'input> = {
    // TODO: capture the inner info instead
    "(" <RawType> ")",

    Tuple<Type> => RawType::Tuple(<>),
    "enum" "{" <variants:CommaSep<(<Ident> ":" <Type>)>> "}" =>
        RawType::Enum(variants.into_iter().collect()),

    "bool" => RawType::Bool,
}
