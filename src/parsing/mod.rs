use annotate_snippets::{AnnotationKind, Group, Level};
use itertools::Itertools;
use lalrpop_util::lalrpop_mod;

use crate::{
    error::RenderError,
    reprs::{ast::Term, common::FileInfo},
};

lalrpop_mod!(
    #[allow(clippy::pedantic)]
    syntax,
    "/parsing/syntax.rs"
);

type UserParserError = std::convert::Infallible;

pub struct ParseError<'i>(
    &'i FileInfo<'i>,
    lalrpop_util::ParseError<usize, lalrpop_util::lexer::Token<'i>, UserParserError>,
);

#[derive(Default)]
pub struct Parser {
    term_parser: syntax::TermParser,
}
impl Parser {
    /// Takes program source code and parses it into an [`ast::Term`][`Term`].
    ///
    /// The parsing code is generated by the `lalrpop` crate, which runs in the build step, from
    /// the `syntax.lalrpop` file.
    ///
    /// The parser actively tries to do as little validation of the source beyond syntax, leaving
    /// 'possibly-syntax' things (like label uniqueness) to the subsequent validation step.
    ///
    /// # Errors
    /// When parsing fails.
    pub fn parse<'i>(&self, file_info: &'i FileInfo<'i>) -> Result<Term<'i>, ParseError<'i>> {
        self.term_parser
            .parse(file_info, file_info.text())
            .map_err(|err| ParseError(file_info, err))
    }
}

impl<'i> RenderError<'i> for ParseError<'i> {
    fn push_groups(self, buf: &mut Vec<Group<'i>>) {
        fn expected_str(expected: &[String]) -> String {
            match expected {
                [] => "expected nothing?".into(),
                [single] => format!("expected: {single}"),
                [start @ .., last] => std::iter::once("expected one of: ")
                    .chain(Itertools::intersperse(
                        start.iter().map(std::ops::Deref::deref),
                        ", ",
                    ))
                    .chain([" or ", last])
                    .collect(),
            }
        }

        let ParseError(file_info, parse_error) = self;

        let snippet = file_info.snippet();
        let group = match parse_error {
            lalrpop_util::ParseError::InvalidToken { location } => Level::ERROR
                .primary_title("Found invalid token")
                .element(snippet.annotation(AnnotationKind::Primary.span(location..location))),

            lalrpop_util::ParseError::UnrecognizedEof { location, expected } => Level::ERROR
                .primary_title("Unexpected EOF")
                .element(snippet.annotation(AnnotationKind::Primary.span(location..location)))
                .element(Level::NOTE.message(expected_str(&expected))),

            lalrpop_util::ParseError::UnrecognizedToken {
                token: (start, token, end),
                expected,
            } => Level::ERROR
                .primary_title(format!("Unexpected token: '{token}'"))
                .element(snippet.annotation(AnnotationKind::Primary.span(start..end).label("here")))
                .element(Level::NOTE.message(expected_str(&expected))),

            lalrpop_util::ParseError::ExtraToken {
                token: (start, token, end),
            } => Level::ERROR
                .primary_title(format!("Unexpected token: '{token}'"))
                .element(snippet.annotation(AnnotationKind::Primary.span(start..end).label("here")))
                .element(Level::NOTE.message("expected nothing")),
        };

        buf.push(group);
    }
}
