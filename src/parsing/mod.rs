use lalrpop_util::lalrpop_mod;

use crate::reprs::ast::Term;

lalrpop_mod!(
    #[allow(clippy::pedantic)]
    syntax,
    "/parsing/syntax.rs"
);

type UserParserError = String;

pub type ParseError<'i> =
    lalrpop_util::ParseError<usize, lalrpop_util::lexer::Token<'i>, UserParserError>;

#[derive(Default)]
pub struct Parser {
    term_parser: syntax::TermParser,
}
impl Parser {
    /// Takes program source code and parses it into an [`ast::Term`][`Term`].
    ///
    /// The parsing code is generated by the `lalrpop` crate, which runs in the build step, from
    /// the `syntax.lalrpop` file.
    ///
    /// The parser actively tries to do as little validation of the source beyond syntax, leaving
    /// 'possibly-syntax' things (like label uniqueness) to the subsequent validation step.
    ///
    /// # Errors
    /// When parsing fails.
    pub fn parse<'i>(&self, input: &'i str) -> Result<Term<'i>, ParseError<'i>> {
        self.term_parser.parse(input)
    }
}
